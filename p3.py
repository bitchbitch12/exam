# -*- coding: utf-8 -*-
"""Sparse matrix PS4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iPLpU79SBCYTdxfOoBCce9XCYFdRk_9a
"""

import math
import numpy as np

q1 = [[1,1.3,2],
      [1.3,3,1.3],
      [2,1.3,1]]

"""## 1.Eigenvalue and eigenvectors using jacobi algo"""

def jacobi_eigen(q1,eigen_vec):

  max_i,max_j = 0,0
  val = float("-inf")
  for i in range(len(q1)):
    for j in range(len(q1)):
      if i == j:
        pass
      else:
        if val < q1[i][j]:
          val = q1[i][j]
          max_i,max_j = i,j

  ortho_mat = [[1 if i == j else 0 for j in range(len(q1))]for i in range(len(q1))]
  den  = (q1[max_i][max_i]-q1[max_j][max_j])
  if den == 0:
    val = (1/2)*math.atan(math.inf)
  else:
    val = (1/2)*math.atan((2*q1[max_i][max_j])/(q1[max_i][max_i]-q1[max_j][max_j]))
  
  ortho_mat[max_i][max_j] = math.sin(val)
  ortho_mat[max_j][max_i] = -math.sin(val)
  ortho_mat[max_i][max_i] = math.cos(val)
  ortho_mat[max_j][max_j] = math.cos(val)

  ans = np.linalg.inv(ortho_mat) @ q1
  ans = ans @ ortho_mat
  
  ans = ans.round()
  diag = (ans.diagonal())
  eigen_vec.append(ortho_mat)
  if ans.sum() == sum(diag):
    print(diag)
    return eigen_vec
  
  else:
    return jacobi_eigen(ans,eigen_vec)

eigen_vec = jacobi_eigen(q1,[])

a , b = eigen_vec[0] , eigen_vec[1]
np.array(a) @ np.array(b)  #@-multiplication

"""## 2.Check if Sparse"""

def issparse(mat):
  zeros ,nonzeros = 0 ,0 
  for i in range(len(mat)):
    for j in range(len(mat[0])):
      if mat[i][j] == 0 : 
        zeros += 1
      else : 
        nonzeros += 1
  
  if zeros > nonzeros:
    return True,zeros,nonzeros
  else:
    return False,zeros,nonzeros

q3 = [[0 ,0 ,3 ,0, 4],
      [0 ,0 ,5 ,7 ,0],
      [0 ,0 ,0 ,0 ,0],
      [0 ,2 ,6 ,0 ,0]]

q4 = [[1 ,0 ,0 ,0, 5],
      [0 ,2 ,0 ,0 ,0],
      [0 ,0 ,3 ,0 ,0],
      [0 ,1 ,0 ,0 ,1]]

issparse(q4)

class Sparese:
  def __init__(self):
    pass

  def transpose(self,a):
    res = {}
    for key in a:
      i,j = key
      res[(j,i)] = a[key]
    
    return res
  
  def mul_sparse(self,a,b):
    res = {}
    for key in a:
      if key in b:
        res[key] = a[key] * b[key]
    
    return res

  def add_sparse(self,a,b):
    res = {}
    for key in a:
      if key in b:
        res[key] = a[key] + b[key]
    
    for key in a:
      if key in res:
        pass
      else:
        res[key] = a[key]    

    for key in b:
      if key in res:
        pass
      else:
        res[key] = b[key]

    return res


  def mat_to_sparse(self,q1):
    mat,max_i,max_j = [],0,0
    for key in q1:
      i,j = key
      max_i = max(i,max_i)
      max_j = max(j,max_j)

    max_i +=1
    max_j += 1
    ans = [[0 for _ in range(max_j)] for _ in range(max_i)]

    for key in q1:
      i,j = key
      # print(i,j)
      ans[i][j] = q1[key]

    return ans

  def sparese_list(self,q1):
    ans = []
    for i in range(len(q1)):
      for j in range(len(q1[0])):
        if q1[i][j] == 0:
          continue
        else:
          ans.append([(i,j),(q1[i][j])])
    return ans
  def sparese_dic(self,q1):
    ans = {}
    for i in range(len(q1)):
      for j in range(len(q1[0])):
        if q1[i][j] == 0:
          continue
        else:
          ans[(i,j)] = q1[i][j]

    return ans

obj = Sparese()

q1_ans = obj.sparese_dic(q3)
q1_ans

obj.sparese_list(q3)

obj.mat_to_sparse(q1_ans)

"""### 4. Convert to Sparse matrices"""

q1= [[0, 0, 1, 1, 3, 3,], 
	 [2, 4, 2, 3, 1, 2,], 
	 [3, 4, 5, 7, 2, 6]]
q2_ans = obj.sparese_dic(q1)
q2_ans

q1_ans = obj.sparese_dic(q3)
q1_ans

"""### 5. i) Addition of 2 sparse matrices"""

ans = obj.add_sparse(q1_ans,q2_ans)
obj.mat_to_sparse(q1)

"""### 5. ii) Transpose of 2 sparse matrices"""

obj.transpose(q1_ans)

obj.mat_to_sparse(obj.transpose(q1_ans))

"""### 5. iii)Multiply 2 sparse matrices"""

obj.mul_sparse(q1_ans,q2_ans)
obj.mat_to_sparse(obj.mul_sparse(q1_ans,q2_ans))